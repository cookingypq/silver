一个非常棒的、以隐私和安全为核心的产品构想

---

# **产品设计文档 (PRD): CodeGuardian - 本地优先的调用链安全分析器**

| **状态** | **版本** | **创建日期** | **作者** |
| :--- | :--- | :--- | :--- |
| 草稿 | 1.0 | 2023-10-27 | Gemini |

## **1. 简介与愿景**

### **1.1 问题陈述**

开发者和安全审计员在审查代码时，需要快速识别从潜在的恶意输入（Source）到危险函数（Sink）的完整攻击路径，即“漏洞调用链”。现有的云端 SAST（静态代码分析安全测试）工具虽然功能强大，但存在数据隐私风险（需要上传源代码）、网络依赖和订阅费用高昂等问题。市场需要一个轻量、快速、保护隐私且可定制的本地代码审计工具。

### **1.2 产品愿景**

打造一款 macOS 原生的、以本地计算为核心的代码安全分析工具。用户只需通过简单的拖拽操作，即可在本地环境中快速发现、理解并可视化代码中的漏洞调用链。通过集成工作流引擎（如 n8n），我们赋予高级用户定义和修改检测规则的能力，实现真正的“一次购买，永久使用，数据私有，规则自定义”。

### **1.3 目标用户**

* **安全工程师/代码审计员:** 需要对大量代码进行快速、初步的安全审计。
* **注重安全的软件开发者:** 希望在开发过程中就能轻松检查自己代码的潜在漏洞。
* **独立开发者/小型团队:** 寻求一个低成本、高效率的本地代码安全解决方案。

## **2. 目标与范围**

### **2.1 产品目标**

* **P0 (核心):** 提供一个能通过拖拽文件夹来启动代码分析的 macOS 应用。
* **P0 (核心):** 在本地环境中完成所有分析，确保源代码永不离开用户设备。
* **P0 (核心):** 能够识别并可视化从数据输入点到危险执行点的调用链。
* **P1 (重要):** 允许用户通过图形化界面（类似 n8n）自定义或修改分析规则。
* **P2 (期望):** 支持主流编程语言（例如：JavaScript/TypeScript, Python, Ruby）。

### **2.2 非目标 (Not in Scope for v1.0)**

* **不做云端同步或团队协作功能。** 严格遵守本地优先原则。
* **不做动态代码分析 (DAST)。** 只进行静态分析。
* **不追求 100% 的漏洞检出率和 0 误报。** 定位为辅助审计工具，而非完全自动化的决策系统。
* **不做 Windows 或 Linux 版本。** 首先聚焦于构建卓越的 macOS 原生体验。

## **3. 功能与需求**

### **3.1 核心功能: 拖拽式代码分析**

* **描述:** 应用主界面提供一个拖拽区域。用户将包含源代码的文件夹拖入该区域后，应用立即在后台启动分析进程。
* **需求:**
    * 支持拖拽单个文件夹。
    * 分析过程中应有清晰的进度指示（如进度条或状态文本）。
    * 分析完成后，自动切换到结果视图。
    * 支持取消正在进行的分析。

### **3.2 核心功能: 漏洞调用链可视化**

* **描述:** 分析结果以列表和图形两种形式展示。列表清晰地标出每个漏洞的类型、源头文件/行号、终点文件/行号。点击某个列表项，可以展开一个图形化的调用链视图。
* **需求:**
    * 结果列表应可排序和过滤（按漏洞类型、文件路径等）。
    * 图形视图应清晰展示从 Source 到 Sink 的函数调用路径。
    * 点击图形视图中的节点（函数名），应能快速跳转到本地 IDE 中对应的代码位置。

### **3.3 核心功能: n8n 驱动的自定义规则引擎**

* **描述:** 应用内置一个“规则编辑器”页面，其界面和操作逻辑类似 n8n。用户可以通过拖拽预设的节点（如 “HTTP 输入”、“SQL 执行”、“文件读写”等）并连接它们，来定义新的漏洞模型。
* **需求:**
    * 提供一个可视化的画布。
    * 提供预设的节点库，包括：
        * **Sources (输入源):** HTTP 请求参数、文件内容、数据库查询结果等。
        * **Sinks (危险终点):** SQL 查询执行、命令执行、代码执行 (`eval`)、文件写入等。
        * **Sanitizers (清洗函数):** HTML 编码、SQL 参数化等。
    * 用户创建的工作流会自动保存为本地 JSON 文件，并被 Rust 分析引擎加载。

## **4. 用户流程**

1. **首次启动:** 用户打开应用，看到简洁的主界面和一个拖拽区域。
2. **分析代码:** 用户将项目文件夹 `my-project` 拖入。
3. **查看结果:** 分析完成后，界面显示发现的 3 个漏洞。用户点击其中一个 "SQL 注入" 漏洞。
4. **深入分析:** 界面展示了从 `controller.js` 的 `req.query.id` 到 `db.js` 的 `executeQuery` 函数的完整调用图。
5. **自定义规则:** 用户觉得默认规则太宽泛，进入“规则编辑器”，将一个自定义的“数据清洗”函数节点拖入到调用链中间，创建了一个新的检测规则。
6. **重新分析:** 用户使用新规则重新分析项目，之前的 SQL 注入漏洞不再报告。

## **5. 成功指标**

* **激活率:** 下载后 7 天内完成一次成功分析的用户比例。
* **核心功能使用率:** “规则编辑器”功能的使用频率。
* **性能:** 对于一个 10 万行代码的项目，完成一次全量分析的时间应在 1 分钟内。

---

# **工程设计文档 (EDD): CodeGuardian**

| **状态** | **版本** | **创建日期** | **作者** |
| :--- | :--- | :--- | :--- |
| 草稿 | 1.0 | 2023-10-27 | Gemini |

## **1. 概述与目标**

### **1.1 摘要**

本文档旨在为 CodeGuardian macOS 应用提供高层架构和详细的工程设计方案。该系统由三个核心部分组成：一个用 **Tauri** 构建的 macOS 原生外壳，一个用 **Rust** 编写的高性能静态分析内核，以及一个嵌入式的 **n8n.io** 实例作为可插拔的规则引擎。

### **1.2 技术目标**

* **高性能:** 利用 Rust 和 tree-sitter 实现快速的代码解析与图遍历。
* **模块化:** 前端 UI、分析引擎、规则引擎三者解耦，通过定义好的接口通信。
* **本地化:** 确保所有组件（包括 n8n）都能在用户的 macOS 环境中离线运行。
* **可扩展性:** 方便未来添加对新语言的支持和新的分析规则节点。

## **2. 系统架构**

### **2.1 高层架构图**

```mermaid
graph TD
    subgraph macOS Application (Tauri)
        A[Frontend UI - React/Svelte]
        B[Tauri Rust Shell]
    end

    subgraph Local Environment
        C[Rust Analysis Core]
        D[Embedded n8n Instance]
        E[User's Source Code]
        F[Analysis Rules - JSON]
    end

    A -- Tauri Commands (Invoke) --> B
    B -- Spawns Process & IPC --> C
    A -- REST API --> D
    D -- Outputs Workflow --> F
    C -- Reads Rules --> F
    C -- Reads Code --> E
    C -- Writes Results (JSON) --> B
    B -- Emits Event --> A

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
```

### **2.2 组件分解**

1. **macOS Application (Tauri):**
    
    * **职责:** 提供用户界面、文件系统交互（拖拽）、接收用户输入、可视化分析结果。
    * **前端 (TS/React):** 构建所有 UI 组件，包括拖拽区、结果列表、n8n风格的规则编辑器画布。
    * **Tauri Shell (Rust):** 作为前端和后端分析引擎的桥梁。它接收前端的 `invoke` 命令（如 `start_analysis`），调用 Rust 分析核心，并通过事件系统 (`event`) 将结果传回给前端。
2. **Rust Analysis Core:**
    
    * **职责:** 执行核心代码分析任务。这是一个独立的、可被命令调用的二进制程序。
    * **技术:**
        * **代码解析:** 使用 `tree-sitter` 库将源代码解析为抽象语法树 (AST)。
        * **图构建:** 基于 AST 构建控制流图 (CFG) 和数据流图 (DFG)。
        * **污点分析:** 实现一个污点跟踪引擎，根据规则（从 n8n 的 JSON 加载）在图中寻找从 Source 到 Sink 的路径。
    * **输入:** 待分析的代码路径、规则文件的路径。
    * **输出:** 一个包含所有漏洞调用链的 JSON 字符串，打印到 `stdout`。
3. **Embedded n8n Instance:**
    
    * **职责:** 提供一个图形化的界面，让用户能够定义分析规则。
    * **实现:**
        * **方案A (推荐):** 在应用启动时，在后台静默启动一个 n8n 的 Docker 容器或本地 Node.js 进程。Tauri 应用内置一个 WebView 指向这个本地 n8n 实例 (`localhost:5678`)。
        * **方案B (备选):** 从头实现一个 n8n 风格的前端画布组件，不依赖真实 n8n。这更轻量，但开发成本高。
    * **定制:** 需要为 n8n 开发自定义节点（Source, Sink, Sanitizer），这些节点不执行任何操作，仅用于生成描述分析逻辑的 JSON 工作流文件。

## **3. 详细设计**

### **3.1 Rust Analysis Core**

1. **入口:** 接收命令行参数 `(source_dir, rules_path)`。
2. **初始化:** 加载 `rules.json` 文件，解析出所有的 Sources, Sinks, 和 Sanitizers 的定义（例如，函数名、参数位置等）。
3. **代码遍历与解析:**
    * 递归遍历 `source_dir` 下的所有支持的源文件。
    * 对每个文件，使用对应的 `tree-sitter` grammar 解析为 AST。
4. **图构建:**
    * 将所有文件的 AST 链接起来，构建一个项目的全局控制流图 (CFG)。
5. **污点分析 (Taint Analysis):**
    * **标记源头 (Sources):** 遍历图，找到所有匹配规则中 Source 定义的节点（如 `req.query.*`），将其标记为“被污染的”。
    * **传播污染:** 沿着数据流和控制流路径传播“污染”标记。
    * **检测终点 (Sinks):** 如果一个被污染的数据流到达了一个 Sink 节点（如 `db.query(...)`），并且中途没有经过对应的 Sanitizer 节点，则记录为一条漏洞调用链。
6. **输出:** 将所有发现的调用链路径格式化为 JSON，输出到 `stdout`，然后进程退出。

### **3.2 n8n 集成与规则定义**

* **工作流格式 (JSON):** 一个标准 n8n 工作流 JSON，包含 `nodes` 和 `connections`。
    ```json
    {
      "nodes": [
        {
          "parameters": { "functionName": "req.query.id" },
          "name": "HTTP Input",
          "type": "CodeGuardian.source",
          "id": "1"
        },
        {
          "parameters": { "functionName": "db.execute" },
          "name": "SQL Execution",
          "type": "CodeGuardian.sink",
          "id": "2"
        }
      ],
      "connections": { "1": { "main": [ [ { "node": "2", "type": "main" } ] ] } }
    }
    ```
* **通信:** Tauri 前端通过 `fetch` API 与本地 n8n 实例的 REST API 交互，获取和保存工作流。当用户保存工作流时，n8n 将其写入本地磁盘的特定位置（如 `~/Library/Application Support/CodeGuardian/rules.json`），以便 Rust 核心读取。

## **4. 开发与部署**

### **4.1 开发流程**

1. **并行开发:**
    * **前端团队:** 使用 React/Svelte 和标准 n8n (或 mock API) 开发 UI 界面。
    * **后端团队:** 独立开发 Rust 分析核心的命令行工具，用静态的 `rules.json` 文件进行测试。
2. **集成:** 将 Rust 核心作为 Tauri `sidecar` 或通过 `Command::spawn` 集成。对接前端与 n8n 实例。

### **4.2 测试策略**

* **单元测试 (Rust):** 针对代码解析、图构建、污点分析算法编写单元测试。
* **集成测试 (Tauri):** 编写测试用例，模拟用户拖拽文件夹，验证从 UI 到 Rust 核心再回到 UI 的完整流程是否正确。
* **E2E 测试:** 使用 Playwright 或 Cypress 测试 Tauri 应用的 UI 交互和 n8n 编辑器。

### **4.3 部署**

* **打包:** 使用 `tauri build` 命令将整个应用（包括 Rust 核心和 n8n 的启动脚本）打包成一个独立的 `.app` 文件和一个 `.dmg` 安装包。
* **分发:** 可以通过网站直接提供 `.dmg` 下载，或上架到 macOS App Store（需要处理沙箱限制）。
